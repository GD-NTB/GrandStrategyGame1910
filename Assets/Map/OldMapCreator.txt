using System.Collections.Generic;
using System.Data;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

public class MapCreator : MonoBehaviour
{
    private MapParent MapParent;
    void Awake()
    {
        MapParent = GameObject.Find("MapParent").GetComponent<MapParent>();
    }

    private Transform statesHolder;
    void Start()
    {
        float startTime = Time.realtimeSinceStartup; // for benchmarking

        // load information from States.json
        LoadStatesFromFile();
        print("loaded States.json");

        // populate colour to state dictionary
        PopulateColourToState();
        print("populated colour to state dictionary");

        // create state GameObjects
        statesHolder = GameObject.Find("StatesHolder").transform; // the parent of all the states
        CreateStateGameObjects();
        print("created states");

        float endTime = Time.realtimeSinceStartup; // for benchmarking
        print($"took {endTime - startTime} seconds to create map");
    }

    private TextAsset statesFile;
    private void LoadStatesFromFile()
    {
        // find and load states file from Resources folder
        statesFile = Resources.Load("Map/States") as TextAsset;

        // deserialise json in states file
        State[] statesArray  = JsonConvert.DeserializeObject<State[]>(statesFile.text);
        // add each state to states in MapState
        foreach (State currentState in statesArray)
        {
            MapParent.mapState.States.Add(currentState);
        }
    }

    private void PopulateColourToState()
    {
        // wipe dictionary
        MapParent.mapState.ColourToState.Clear();
        // for each state that exists, create a new entry for it
        foreach (State currentState in MapParent.mapState.States)
        {
            MapParent.mapState.ColourToState.Add(currentState.StatesMapColour, currentState);
        }

        // foreach (KeyValuePair<Color, State> kvp in MapParent.mapState.ColourToState)
        // {
        //     print($"Key = {kvp.Key}, Value = {kvp.Value}");
        // }
    }
    
    private GameObject StatePrefab;
    private Texture2D StatesTexture;
    private void CreateStateGameObjects()
    {
        // load state prefab
        StatePrefab = Resources.Load("Map/StatePrefab") as GameObject;
        // load states texture
        StatesTexture = Resources.Load("Map/StatesMap") as Texture2D;

        // make a array of "holders" that will contain all the pixels of each state
        // credit to Zuabros, https://stackoverflow.com/a/62309989
        int numberOfStates = MapParent.mapState.States.Count();
        List<Vector2Int>[] pixelHolders = Enumerable.Range(0, numberOfStates).Select(_ => new List<Vector2Int>()).ToArray();

        // iterate through every pixel on the map of states
        for (int y = 0; y < StatesTexture.height; y++)
        {
            for (int x = 0; x < StatesTexture.width; x++)
            {
                Color pixelColour = StatesTexture.GetPixel(x, y);
                if (pixelColour.a == 0) { continue; } // if transparent pixel, skip

                // find corresponding state using colour to state dictionary
                State state;
                // if there is no corresponding state for this colour, then the colour is not defined, skip
                if (!MapParent.mapState.ColourToState.TryGetValue(pixelColour, out state))
                {
                    // Debug.LogWarning($"undefined colour {pixelColour} at ({x}, {y})");
                    continue;
                }

                // add pixel to corresponding holder
                pixelHolders[state.ID-1].Add(new Vector2Int(x, y));
            }
        }

        // now we have a list of every pixel of every state (todo: store this in state class?)
        // now go through each state, instantiate its respective gameobject, and construct its sprite and texture
        foreach (State state in MapParent.mapState.States)
        {
            // get pixels of this state
            Vector2Int[] pixels = pixelHolders[state.ID-1].ToArray();

            // instantiate gameobject from prefab
            GameObject stateGameObject = Instantiate(StatePrefab, statesHolder);
            stateGameObject.name = state.Name;

            // in order to create a texture2d, we need to find the dimensions of the state
            // to do this, we can seperate the x and y values and use the min/max of them.
            int pixelCount = pixels.Length;
            int[] x_values = new int[pixelCount];
            int[] y_values = new int[pixelCount];
            for (int i = 0; i < pixelCount; i++)
            {
                x_values[i] = pixels[i].x;
                y_values[i] = pixels[i].y;
            }
            Vector2Int stateTopLeft = new Vector2Int(Mathf.Min(x_values), Mathf.Min(y_values)); // we will use this when painting pixels onto the texture2d
            int stateWidth = Mathf.Max(x_values) - stateTopLeft.x + 1; // the "bounding box" width
            int stateHeight = Mathf.Max(y_values) - stateTopLeft.y + 1; // the "bounding box" height
            
            // create transparent texture with state width and height dimensions
            Texture2D stateTexture = new Texture2D(stateWidth, stateHeight, TextureFormat.RGBA32, false);
            Color[] emptyPixels = new Color[stateWidth * stateHeight]; // all colours initialise transparent
            stateTexture.filterMode = FilterMode.Point;
            stateTexture.SetPixels(emptyPixels);

            // for every pixel in the state, paint it onto the texture2d
            foreach (Vector2Int pixel in pixels)
            {
                stateTexture.SetPixel(pixel.x - stateTopLeft.x, pixel.y - stateTopLeft.y, state.StatesMapColour); // corresponding pixel is offset by top left corner position
            }
            // apply all changes
            stateTexture.Apply();
            
            // create new sprite with texture and assign to state
            Sprite stateSprite = Sprite.Create(stateTexture,
                                              new Rect(0.0f, 0.0f, stateWidth, stateHeight),
                                              new Vector2(0.5f, 0.5f), 100.0f,
                                              0,
                                              SpriteMeshType.FullRect);
            stateGameObject.GetComponent<SpriteRenderer>().sprite = stateSprite;

            // last step is to position the state in the right place
            // the center of the state will be the top left corner + state size/2
            // (stateTopLeft.x + stateWidth*0.5f - 2500.0f)/100.0f
            stateGameObject.transform.position = new Vector3((stateTopLeft.x + stateWidth*0.5f - 2500.0f)/100.0f, 
                                                             (stateTopLeft.y + stateHeight*0.5f - 1250.0f)/100.0f,
                                                             -1.0f);
            
            // done!
        }
    }
}